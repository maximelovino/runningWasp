\documentclass[a4paper,11pt]{article}
\usepackage{amsmath}
\usepackage[frenchb]{babel}
\usepackage[utf8]{inputenc}
\usepackage{fontspec} 
\usepackage[T1]{fontenc}
\usepackage{amssymb}
\title{Université d'été - Rapport}
\author{Ibanez Thomas, Lovino Maxime, Tournier Vincent}
\begin{document}
\maketitle
\section{Introduction}
WaspRunner est un projet miniature et compact de traceur GPS pour joggeurs soucieux de travailler leur VMA.\newline
WaspRunner se compose de trois éléments : un module traceur à emporter avec soi durant la course (fort heureusement le module est léger et compact - il peut facilement être transporté dans une valise à roulette), un serveur web sur Raspberry Pi, ainsi que d'une application Android.\newline
Le traceur est lui-même fait d'une carte waspmote équipée d'un module GPS et GPRS, d'une carte wifi dont la simplicité n'a d'égal que la fiabilité, d'une batterie faisant aussi office de lest pour que le coureur ne dépasse pas les limitations de vitesses du code de la route, ainsi que d'une carte microSD pour sauvegarder les courses.\newline
Le serveur web récupère les données GPS du traceur, les traite et les stocke. Il fournit également la possibilité de consulter les rapports de courses sur Internet.\newline
L'application Android permet quant à elle de recevoir les rapports de course directement sur son smartphone.\newline
\section{Réalisation}
\subsection{Base de données}
La base de données se présente selon le schéma suivant: \newline
\includegraphics[scale=0.4]{db.png}
\subsection{Récupération et envoi des données GPS}
La première étape pour notre application est de récupérer la position actuelle via GPS, le module GPRS+GPS de la Waspmote s'occupe de nous donner la position en degrés [-180;180].\newline
Nous appliquons ensuite un code correcteur d'erreurs afin d'éviter qu'un problème de communication n'entraine l'insertion de fausses données dans la course.\newline
Une fois la position définie, la waspmote, si une carte SIM et une connexion sont disponible, va envoyer une requête GET sur l'application web (page run.php), en définissant des flags dans l'url qui seront interprétés par le code php.
\begin{itemize}
\item uid: l'identifiant de l'utilisateur courant, (par défaut 1)
\item start: doit être défini en cas de début de course
\item x: longitude (en degrés)
\item y: latitude (en degrés)
\item cnt: numéro du point envoyé
\item time: temps (en seconde) écoulé depuis le début de la course
\item end: envoyé en fin de course
\end{itemize}
Voici un exemple de communication entre la waspmote et l'application web
\begin{itemize}
\item /run.php?uid=1\&start
\item /run.php?uid=1\&x=<longitude>\&y=<latitude>\&time=12\&cnt=1
\item /run.php?uid=1\&x=<longitude>\&y=<latitude>\&time=18\&cnt=2
\item /run.php?uid=1\&x=<longitude>\&y=<latitude>\&time=23\&cnt=3
\item \ldots
\item /run.php?uid=1\&time=2704\&end
\end{itemize}

\subsection{Traitement des données}
L'application web s'occupe du lien avec la base de données, au départ de la course un fannion running dans la ligne de l'utilisateur est défini à l'id de la course en cours.\newline
Ensuite à chaque fois qu'un point est envoyé, données du point (x,y,cnt et time) sont ajoutés dans la table t\_rundata.\newline
Lorsque l'application reçoit le fannion end, la case running de l'utilisateur est remise à 0 et les statistiques de course sont calculées.
Le calcul de la distance au sol est fait par la formule d'Haversine.
\begin{equation*}
a = sin^2(\frac{\varphi_1 - \varphi_2}{2}) + cos(\varphi_1) * cos(\varphi_2) * sin^2(\frac{\lambda_1 - \lambda_2}{2})
\end{equation*}
\begin{equation*}
d = 2r *arctan\left(\frac{\sqrt{a}}{\sqrt{1-a}}\right)
\end{equation*}
Où \newline
$\varphi_1 \; et \; \varphi_2$ sont les longitudes des deux points\newline
$\lambda_1 \; et \; \lambda_2$ sont les latitudes des deux points\newline
$r$ est le rayon de la terre (6371 Km)\newline
\subsection{Stockage des données en cas de problème de réseau}
Dans le cas où le module est incapable, pour une raison ou une autre, de se connecter au réseau GPRS avant qu'une course ne soit démarrée, il nous a fallu trouver un moyen de ne pas rendre le module inutilisable. Pour cela, nous avons fait le choix de permettre à l'utilisateur de sauvegarder les données de la course sur une carte SD.\newline
Dans le cas où le réseau GPRS est inaccessible au moment où doit démarrer une course, les données GPS et tous les points sont sauvegardés sur un fichier texte présent dans la carte SD, sous la forme de lignes de commandes. La course se déroule alors normalement, chaque point étant sauvegardé sur la carte SD.\newline
Lorsque la course est stoppée, le fichier est rendu disponible à l'envoi. Immédiatement, la carte WiFly s'active et essaye de se connecter au réseau WiFi sauvegardé dans sa configuration. De la même manière, si la carte s'allume et qu'un fichier de course est présent en mémoire, elle essayera d'abord d'envoyer le fichier avant de laisser l'utilisateur démarrer une course.\newline
Sitôt que la carte parvient à se connecter à un réseau WiFy, elle ouvre une connexion vers un socket java présent sur le serveau web. Lorsque la connexion TCP est établie, la carte envoie ligne par ligne les données présentes sur le fichier, puis se déconnecte et, si les données ont été correctement envoyée, détruit le fichier. Une nouvelle course peut alors être lancée.\newline
Dans le cas où la carte est incapable d'obtenir une connexion WiFi ou TCP, et ce afin d'éviter un comportement bloquant pour l'utilisateur, un timeout a été mis en place. Globalement, une tentative de connexion prend 5 secondes, aussi nous avons limité le nombre de tentatives à 12 afin que la carte essaye de se connecter pendant environ une minute avant d'abandonner et de laisser l'utilisateur démarrer, s'il le souhaite, une nouvelle course. Par ailleurs, si cette nouvelle course doit être enregistrée sur la carte SD, elle sera simplement ajoutée à la suite de celle déjà présente.\newline


\end{document}
